generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Para conexão direta (migrations)
}

model Organization {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  logo      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users         User[]
  channels      Channel[]
  announcements Announcement[]
}

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  password       String
  name           String
  avatar         String?
  status         String   @default("offline") // online, offline, away, busy
  statusMessage  String?
  role           String   @default("member") // admin, member
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization    Organization      @relation(fields: [organizationId], references: [id])
  messages        Message[]
  channelMembers  ChannelMember[]
  sentDMs         DirectMessage[]   @relation("SentMessages")
  receivedDMs     DirectMessage[]   @relation("ReceivedMessages")
  notifications   Notification[]
  reactions       Reaction[]
  announcements   Announcement[]    @relation("AnnouncementCreator")
  asRecipient     AnnouncementRecipient[] @relation("RecipientUser")
}

model Channel {
  id             String   @id @default(uuid())
  name           String
  description    String?
  isPrivate      Boolean  @default(false)
  organizationId String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization    @relation(fields: [organizationId], references: [id])
  messages     Message[]
  members      ChannelMember[]

  @@unique([name, organizationId])
}

model ChannelMember {
  id        String   @id @default(uuid())
  userId    String
  channelId String
  role      String   @default("member") // admin, member
  joinedAt  DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([userId, channelId])
}

model Message {
  id        String   @id @default(uuid())
  content   String   @db.Text
  userId    String
  channelId String
  parentId  String?  // Para threads
  edited    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   Channel    @relation(fields: [channelId], references: [id], onDelete: Cascade)
  parent    Message?   @relation("ThreadMessages", fields: [parentId], references: [id])
  replies   Message[]  @relation("ThreadMessages")
  reactions Reaction[]
  files     File[]
}

model DirectMessage {
  id         String   @id @default(uuid())
  content    String   @db.Text
  senderId   String
  receiverId String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  sender   User   @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User   @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
}

model Reaction {
  id        String   @id @default(uuid())
  emoji     String
  userId    String
  messageId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId, emoji])
}

model Notification {
  id        String   @id @default(uuid())
  type      String   // message, mention, channel_invite
  title     String
  content   String   @db.Text
  read      Boolean  @default(false)
  userId    String
  data      String?  @db.Text // JSON string with additional data
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model File {
  id        String   @id @default(uuid())
  name      String
  url       String
  type      String
  size      Int
  messageId String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
}

// ==========================================
// MÓDULO DE E-MAIL MARKETING / COMUNICADOS
// ==========================================

model Announcement {
  id             String   @id @default(uuid())
  title          String
  subject        String   // Assunto do e-mail
  htmlContent    String   @db.Text // Conteúdo HTML do e-mail (do GrapesJS)
  jsonContent    String?  @db.Text // JSON do GrapesJS para edição futura
  status         String   @default("draft") // draft, scheduled, sending, sent, cancelled
  scheduledAt    DateTime?
  sentAt         DateTime?
  organizationId String
  createdById    String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization Organization      @relation(fields: [organizationId], references: [id])
  createdBy    User              @relation("AnnouncementCreator", fields: [createdById], references: [id])
  emailLogs    EmailLog[]
  analytics    AnalyticsEvent[]
  recipients   AnnouncementRecipient[]
}

model AnnouncementRecipient {
  id             String  @id @default(uuid())
  announcementId String
  email          String
  name           String?
  userId         String? // Se for um usuário interno
  status         String  @default("pending") // pending, sent, delivered, bounced, failed

  announcement Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  user         User?        @relation("RecipientUser", fields: [userId], references: [id])

  @@unique([announcementId, email])
}

model EmailLog {
  id             String   @id @default(uuid())
  announcementId String
  recipientEmail String
  resendId       String?  // ID retornado pelo Resend
  status         String   @default("pending") // pending, sent, delivered, bounced, failed, complained
  errorMessage   String?
  sentAt         DateTime?
  deliveredAt    DateTime?
  openedAt       DateTime?
  clickedAt      DateTime?
  bouncedAt      DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  announcement Announcement     @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  events       AnalyticsEvent[]
}

model AnalyticsEvent {
  id             String   @id @default(uuid())
  type           String   // open, click, bounce, complaint, unsubscribe
  announcementId String
  emailLogId     String?
  recipientEmail String
  metadata       String?  @db.Text // JSON com dados adicionais (ex: link clicado, user agent)
  ipAddress      String?
  userAgent      String?  @db.Text
  createdAt      DateTime @default(now())

  announcement Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  emailLog     EmailLog?    @relation(fields: [emailLogId], references: [id])

  @@index([announcementId])
  @@index([type])
  @@index([recipientEmail])
}

model TrackedLink {
  id             String   @id @default(uuid())
  announcementId String
  originalUrl    String   @db.Text
  trackingCode   String   @unique // Código único para o link
  clickCount     Int      @default(0)
  createdAt      DateTime @default(now())

  @@index([trackingCode])
  @@index([announcementId])
}

// Adicione no final do arquivo schema.prisma

model Contact {
  id        String   @id @default(uuid())
  name      String?
  email     String   @unique
  createdAt DateTime @default(now())

  @@map("contacts")
}